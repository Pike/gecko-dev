<?xml version="1.0"?>

<!-- This Source Code Form is subject to the terms of the Mozilla Public
   - License, v. 2.0. If a copy of the MPL was not distributed with this
   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->

<bindings id="localizationBindings"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="localization">
    <implementation implements="nsIDOMEventListener, nsIMessageListener, nsIObserver">
      <constructor>
        <![CDATA[
          const { utils: Cu } = Components;
          Cu.import("resource://gre/modules/Console.jsm");

          const sources = Array.from(this.children).map(
            child => child.getAttribute('src')
          );

          console.log(sources);

          // import Localization.jsm, get resource links, create requestBundles 
          // which can be used by Localization

          // src/bindings/observer: move to a JSM?

          const rootId = this.getAttribute('observe');

          if (!rootId) {
            return;
          }

          const observer = new MutationObserver(translateMutations);
          const observerConfig = {
            attributes: true,
            characterData: false,
            childList: true,
            subtree: true,
            attributeFilter: ['data-l10n-id', 'data-l10n-args'],
          };

          const root = document.getElementById(rootId);
          observer.observe(root, observerConfig);
          translateFragment(root);


          // src/bindings/dom: move to a JSM

          const reHtml = /[&<>]/g;
          const htmlEntities = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
          };

          function getTranslatables(element) {
            const nodes = Array.from(element.querySelectorAll('[data-l10n-id]'));

            if (typeof element.hasAttribute === 'function' &&
                element.hasAttribute('data-l10n-id')) {
              nodes.push(element);
            }

            return nodes;
          }

          function translateFragment(frag) {
            return translateElements(getTranslatables(frag));  
          }

          function translateMutations(mutations) {
            const targets = new Set();

            for (let mutation of mutations) {
              switch (mutation.type) {
                case 'attributes':
                  targets.add(mutation.target);
                  break;
                case 'childList':
                  for (let addedNode of mutation.addedNodes) {
                    if (addedNode.nodeType === addedNode.ELEMENT_NODE) {
                      if (addedNode.childElementCount) {
                        getTranslatables(addedNode).forEach(targets.add.bind(targets));
                      } else {
                        if (addedNode.hasAttribute('data-l10n-id')) {
                          targets.add(addedNode);
                        }
                      }
                    }
                  }
                  break;
              }
            }

            if (targets.size === 0) {
              return;
            }

            translateElements(Array.from(targets));
          }

          function getElementsTranslation(elems) {
            // XXX optimize querying the <localization> element
            const keys = elems.map(elem => {
              const id = elem.getAttribute('data-l10n-id');
              const args = elem.getAttribute('data-l10n-args');
              const l10n = document.getElementById(elem.getAttribute('localization'));
              return [
                l10n,
                id,
                args ? JSON.parse(args.replace(reHtml, match => htmlEntities[match])) : null
              ];
            });

            return Promise.all(
              keys.map(([l10n, id, args]) => l10n.formatEntity(id, args))
            );
          }

          function translateElements(elements) {
            return getElementsTranslation(elements).then(
              translations => applyTranslations(elements, translations));
          }

          function applyTranslations(elems, translations) {
            observer.disconnect();
            for (let i = 0; i < elems.length; i++) {
              overlayElement(elems[i], translations[i]);
            }
            observer.observe(document, observerConfig);
          }


          // src/bindings/overlay: move to a JSM

          // match the opening angle bracket (<) in HTML tags, and HTML entities like
          // &amp;, &#0038;, &#x0026;.
          const reOverlay = /<|&#?\w+;/;

          const allowed = {
            elements: [
              'a', 'em', 'strong', 'small', 's', 'cite', 'q', 'dfn', 'abbr', 'data',
              'time', 'code', 'var', 'samp', 'kbd', 'sub', 'sup', 'i', 'b', 'u',
              'mark', 'ruby', 'rt', 'rp', 'bdi', 'bdo', 'span', 'br', 'wbr'
            ],
            attributes: {
              global: ['title', 'aria-label', 'aria-valuetext', 'aria-moz-hint'],
              a: ['download'],
              area: ['download', 'alt'],
              button: ['accesskey'], // used by XUL
              // value is special-cased in isAttrAllowed
              input: ['alt', 'placeholder'],
              menuitem: ['label'],
              menu: ['label'],
              optgroup: ['label'],
              option: ['label'],
              tab: ['label'],
              textbox: ['placeholder'],
              track: ['label'],
              img: ['alt'],
              textarea: ['placeholder'],
              th: ['abbr']
            }
          };

          function overlayElement(element, translation) {
            const value = translation.value;

            if (typeof value === 'string') {
              if (!reOverlay.test(value)) {
                element.textContent = value;
              } else {
                // start with an inert template element and move its children into
                // `element` but such that `element`'s own children are not replaced
                const tmpl = element.ownerDocument.createElementNS(
                  'http://www.w3.org/1999/xhtml', 'template');
                tmpl.innerHTML = value;
                // overlay the node with the DocumentFragment
                overlay(element, tmpl.content);
              }
            }

            for (let key in translation.attrs) {
              if (isAttrAllowed({ name: key }, element)) {
                element.setAttribute(key, translation.attrs[key]);
              }
            }
          }

          // The goal of overlay is to move the children of `translationElement`
          // into `sourceElement` such that `sourceElement`'s own children are not
          // replaced, but only have their text nodes and their attributes modified.
          //
          // We want to make it possible for localizers to apply text-level semantics to
          // the translations and make use of HTML entities. At the same time, we
          // don't trust translations so we need to filter unsafe elements and
          // attributes out and we don't want to break the Web by replacing elements to
          // which third-party code might have created references (e.g. two-way
          // bindings in MVC frameworks).
          function overlay(sourceElement, translationElement) {
            const result = translationElement.ownerDocument.createDocumentFragment();
            let k, attr;

            // take one node from translationElement at a time and check it against
            // the allowed list or try to match it with a corresponding element
            // in the source
            let childElement;
            while ((childElement = translationElement.childNodes[0])) {
              translationElement.removeChild(childElement);

              if (childElement.nodeType === childElement.TEXT_NODE) {
                result.appendChild(childElement);
                continue;
              }

              const index = getIndexOfType(childElement);
              const sourceChild = getNthElementOfType(sourceElement, childElement, index);
              if (sourceChild) {
                // there is a corresponding element in the source, let's use it
                overlay(sourceChild, childElement);
                result.appendChild(sourceChild);
                continue;
              }

              if (isElementAllowed(childElement)) {
                const sanitizedChild = childElement.ownerDocument.createElement(
                  childElement.nodeName);
                overlay(sanitizedChild, childElement);
                result.appendChild(sanitizedChild);
                continue;
              }

              // otherwise just take this child's textContent
              result.appendChild(
                translationElement.ownerDocument.createTextNode(
                  childElement.textContent));
            }

            // clear `sourceElement` and append `result` which by this time contains
            // `sourceElement`'s original children, overlayed with translation
            sourceElement.textContent = '';
            sourceElement.appendChild(result);

            // if we're overlaying a nested element, translate the allowed
            // attributes; top-level attributes are handled in `translateElement`
            // XXX attributes previously set here for another language should be
            // cleared if a new language doesn't use them; https://bugzil.la/922577
            if (translationElement.attributes) {
              for (k = 0, attr; (attr = translationElement.attributes[k]); k++) {
                if (isAttrAllowed(attr, sourceElement)) {
                  sourceElement.setAttribute(attr.name, attr.value);
                }
              }
            }
          }

          // XXX the allowed list should be amendable; https://bugzil.la/922573
          function isElementAllowed(element) {
            return allowed.elements.indexOf(element.tagName.toLowerCase()) !== -1;
          }

          function isAttrAllowed(attr, element) {
            const attrName = attr.name.toLowerCase();
            const tagName = element.tagName.toLowerCase();
            // is it a globally safe attribute?
            if (allowed.attributes.global.indexOf(attrName) !== -1) {
              return true;
            }
            // are there no allowed attributes for this element?
            if (!allowed.attributes[tagName]) {
              return false;
            }
            // is it allowed on this element?
            // XXX the allowed list should be amendable; https://bugzil.la/922573
            if (allowed.attributes[tagName].indexOf(attrName) !== -1) {
              return true;
            }
            // special case for value on inputs with type button, reset, submit
            if (tagName === 'input' && attrName === 'value') {
              const type = element.type.toLowerCase();
              if (type === 'submit' || type === 'button' || type === 'reset') {
                return true;
              }
            }
            return false;
          }

          // Get n-th immediate child of context that is of the same type as element.
          // XXX Use querySelector(':scope > ELEMENT:nth-of-type(index)'), when:
          // 1) :scope is widely supported in more browsers and 2) it works with
          // DocumentFragments.
          function getNthElementOfType(context, element, index) {
            /* jshint boss:true */
            let nthOfType = 0;
            for (let i = 0, child; child = context.children[i]; i++) {
              if (child.nodeType === child.ELEMENT_NODE &&
                  child.tagName.toLowerCase() === element.tagName.toLowerCase()) {
                if (nthOfType === index) {
                  return child;
                }
                nthOfType++;
              }
            }
            return null;
          }

          // Get the index of the element among siblings of the same type.
          function getIndexOfType(element) {
            let index = 0;
            let child;
            while ((child = element.previousElementSibling)) {
              if (child.tagName === element.tagName) {
                index++;
              }
            }
            return index;
          }

        ]]>
      </constructor>

      <method name="formatEntity">
        <parameter name="id"/>
        <parameter name="args"/>
        <body>
          <![CDATA[
            console.log(this, id);
            return {
              value: null,
              attrs: {
                label: "Nowa karta",
                placeholder: "Wprowadź adres lub szukaj"
              }
            };
          ]]>
        </body>
      </method>

    </implementation>
  </binding>

</bindings>
